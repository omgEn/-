内部排序 即在内存中装入所有的数据

稳定性：任何两个相对的数据，排序前后的相对位置不发生改变

没有一种排序是任何情况下都表现最好

void X_Sort(ElementType A[],int N)

最好：顺序T=O()  最坏逆序T=O()  稳定

### 一、简单排序

#### 冒泡排序

冒泡排序：从上到下标记两个相邻的数 ，一趟排序完成之后，最大的一定在最后

````c
void Bubble_Sort(ElementType A[],int N)
{
    for(p=N-1;p>=0;p--){
    flag=0;
    for( i=0;i<p;i++)//一趟冒泡
	{
    	if(A[i]>A[i+1]) Swap(A[i],A[i+1]);
    	flag=1;//标识发生了交换
	}
	if(flag==0)break;//全程无交换
	}
}
````

最好：顺序T=O(n)  最坏逆序T=O(n2)  稳定

#### 插入排序：抓牌

````c
void Insertion_Sort(ElementType A[],int N)
{
	for(p=1;p<N;p++)
    {
        Tmp=A[p];//摸下第一张牌
        for(i=p;i>0&&A[i-1]>Tmp;i--){
        A[i]=A[i-1];//移出空位
    	}
    	A[i]=Tmp;//新牌落位
    }
}
````

最好：顺序T=O(n)  最坏逆序T=O(n2)  稳定

给 {8,34,51,32,64}分别用冒泡和插入排序 都是9次 ，逆序对是9对，交换两个相邻元素正好消除一个逆序对

时间复杂度下界

逆序对：下标i<j,如果A[i]>A[j] 

时间复杂度下界

逆序对：下标i<j,如果A[i]>A[j] 

插入排序

如果序列基本有序，则插入排序简单且高效

定理：任意N个不同元素组成的序列平均具有N(N-1)/4个逆序对

定理：任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为Ώ(N2)

这意味着：要提高算法效率，我们必须

每次消去不止一个逆序对

每次交换相隔较远的2个元素

### 二、希尔排序

利用插入排序的简单，同时克服了每次只交换相邻两个元素的缺点 

````c
void Shell_Sort(ElementType A[],int N)
{
    for(p=D;D>0;D/=2)
    {
    	for(p=D;P<N;p++)
    	{
            Tmp=A[p];
            for(i=p;i>=D&&A[i-D]>Tmp;i-=D)
            {
            	A[i]=A[i-D]
            }
            A[i]=Tmp;
    	}
    }
}
````

最好：顺序T=O()  最坏逆序T=θ(n2) 既是上界也是下界 

增量元素不互质，则最小增量可能根本不起作用

### 三、堆排序

